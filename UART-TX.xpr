`timescale 1ns / 1ps

module uart(
    input clk,reset,
    input [7:0] data_in,
    input tx_start,
    output reg tx,
    output reg tx_done
    );
    
    reg[3:0] state,nxt_state;
    reg[2:0] bit_indx;
    reg[7:0] data_reg;
    
    parameter IDLE=0,START=1,DATA=2,STOP=3,FINISH=4;
    always @(posedge clk)
    begin
    if (reset)
       state=IDLE;
    else
       state=nxt_state;
    end
    
    always@(*)
    begin
    case(state)
              IDLE: nxt_state=tx_start? START:IDLE;
              START:nxt_state=DATA;
              DATA:nxt_state=(bit_indx==7)? STOP:DATA;
              STOP:nxt_state=FINISH;
              FINISH:nxt_state=IDLE;
              default:nxt_state=IDLE;
     endcase
     end
     
     always@(posedge clk)
     begin
     if(reset)
     begin
       tx=1'b1;
       bit_indx=0;
       tx_done=0;
     end
     else
     begin
     case(state)
           IDLE:
           begin
           tx=1'b1;
           tx_done=0;
           bit_indx=0;
           end
           
           START:
           begin
           data_reg=data_in;
           bit_indx=0;
           end
           DATA:
           begin
           tx=data_reg[bit_indx];
           bit_indx=bit_indx+1; 
           end
           STOP:
           begin
           tx=1'b1;
           end
           FINISH:
           begin
           tx_done=1'b1;
           end
      endcase
   end
  
  end
  
   
endmodule

module uart_tb;
 reg clk,reset;
 reg[7:0] data_in;
 reg tx_start;
 wire tx;
 wire tx_done;
 
 uart m1(clk,reset,data_in,tx_start,tx,tx_done);

 always#10 clk=~clk;
 
 initial
 begin
 clk=0;
 reset=1'b1;
 data_in=8'h00;
 tx_start=1'b0;
 #20;
     data_in = 8'hA5;  // Example byte: 10100101
     tx_start = 1;
     #20;
     tx_start = 0;
 
     // Wait for tx_done signal
     wait(tx_done);
     #50;
 
     // End simulation
     $finish;
   end
