`timescale 1ns/1ps

module uart_rx #
(
    parameter CLKS_PER_BIT = 5208
)
(
    input  wire       clk,
    input  wire       reset,
    input  wire       rx,
    output reg [7:0]  data_out,
    output reg        rx_done
);

    localparam IDLE  = 3'd0,
               START = 3'd1,
               DATA  = 3'd2,
               STOP  = 3'd3,
               DONE  = 3'd4;

    reg [2:0]  state;
    reg [12:0] clk_count;
    reg [2:0]  bit_index;
    reg [7:0]  rx_data_temp;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state        <= IDLE;
            rx_done      <= 1'b0;
            clk_count    <= 0;
            bit_index    <= 0;
            data_out     <= 0;
            rx_data_temp <= 0;
        end else begin
            case (state)
                IDLE: begin
                    rx_done   <= 1'b0;
                    clk_count <= 0;
                    bit_index <= 0;
                    
                    // Start bit detected (falling edge)
                    if (rx == 1'b0) begin
                        state <= START;
                    end
                end

                // Wait middle of start bit to verify it's still low
                START: begin
                    if (clk_count == (CLKS_PER_BIT-1)/2) begin
                        if (rx == 1'b0) begin
                            clk_count <= 0;
                            state     <= DATA;
                        end else begin
                            state <= IDLE; // False start
                        end
                    end else begin
                        clk_count <= clk_count + 1;
                    end
                end

                // Sample bits 0-7
                DATA: begin
                    if (clk_count == CLKS_PER_BIT-1) begin
                        clk_count <= 0;
                        rx_data_temp[bit_index] <= rx;
                        
                        if (bit_index == 7) begin
                            bit_index <= 0;
                            state     <= STOP;
                        end else begin
                            bit_index <= bit_index + 1;
                        end
                    end else begin
                        clk_count <= clk_count + 1;
                    end
                end

                // Wait for Stop bit (should be high)
                STOP: begin
                    if (clk_count == CLKS_PER_BIT-1) begin
                        state     <= DONE;
                        clk_count <= 0;
                    end else begin
                        clk_count <= clk_count + 1;
                    end
                end

                DONE: begin
                    data_out <= rx_data_temp;
                    rx_done  <= 1'b1;
                    state    <= IDLE;
                end
                
                default: state <= IDLE;
            endcase
        end
    end
endmodule

